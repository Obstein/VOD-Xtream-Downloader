<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ series_info.name }} - Szczegóły Serialu</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; }
        .container { max-width: 900px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2 { color: #333; text-align: center; }
        .series-info { text-align: center; margin-bottom: 20px; }
        .series-info img { max-width: 200px; height: auto; border-radius: 8px; margin-bottom: 10px; }
        .season-list { margin-top: 30px; }
        .episode-list { list-style: none; padding: 0; }
        .episode-list li {
            background-color: #f8f8f8;
            border: 1px solid #eee;
            margin-bottom: 5px;
            padding: 10px 15px;
            border-radius: 5px;
            display: flex; /* Użyj flexboxa dla lepszego ułożenia */
            justify-content: space-between; /* Rozłóż elementy na końcach */
            align-items: center; /* Wyśrodkuj pionowo */
        }
        .episode-list li span.episode-title { /* Styl dla tytułu odcinka */
            flex-grow: 1; /* Pozwól tytułowi zajmować dostępną przestrzeń */
            margin-right: 10px;
        }
        .episode-list li .download-buttons button, .episode-list li .download-buttons a {
            padding: 5px 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 5px;
            text-decoration: none;
            font-size: 0.9em;
        }
        .episode-list li .download-buttons button:hover, .episode-list li .download-buttons a:hover {
            background-color: #0056b3;
        }
        .episode-status {
            font-weight: bold;
            margin-right: 10px; /* Dodaj odstęp od przycisków */
            color: #28a745; /* Zielony dla pobranego */
        }
        /* Style dla różnych statusów */
        .episode-status[data-status="⏳"] { color: #ffc107; } /* Żółty dla w trakcie/oczekującego */
        .episode-status[data-status="❌"] { color: #dc3545; } /* Czerwony dla błędu */
        .episode-status[data-status="✅ Pobrano"] { color: #28a745; } /* Zielony dla pobranego */

        /* Pływająca ramka kolejki (skopiuj z seriale_list.html) */
        #download-queue-widget {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 400px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none; /* Domyślnie ukryte */
            flex-direction: column;
            overflow: hidden;
        }
        #queue-header {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }
        #toggle-queue-widget {
            background: none;
            border: none;
            color: white;
            font-size: 1.2em;
            cursor: pointer;
            padding: 0 5px;
        }
        #queue-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 0.9em;
            color: #343a40;
        }
        #download-queue-widget button {
            border: none;
            background-color: #dc3545;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 0.8em;
        }
        #download-queue-widget button:hover {
            background-color: #c82333;
        }
        #queue-list { list-style: none; padding: 0; margin: 0; }
        #queue-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid #e9ecef;
        }
        #queue-list li:last-child { border-bottom: none; }
        #toggle-queue-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.5em;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 999;
        }
        #toggle-queue-btn:hover { background-color: #218838; }
    </style>
</head>
<body>
    <div class="container">
        <h1>{{ series_info.name }}</h1>
        <div class="series-info">
            {# Jeśli chcesz mieć okładkę serialu na stronie szczegółów, możesz tutaj użyć proxy_image #}
            {# {% if series_info.cover %}
                <img src="{{ url_for('seriale.proxy_image', url=series_info.cover|urlencode) }}" alt="{{ series_info.name }} cover">
            {% endif %} #}
            <p>{{ series_info.plot }}</p>
        </div>

        <div class="season-list">
            {% for season_num in episodes_by_season|sort %}
            <h2>Sezon {{ season_num }}</h2>
            <ul class="episode-list">
                {% for episode in episodes_by_season[season_num] %}
                <li>
                    <span class="episode-title">
                        {{ episode.episode_num }}. {{ episode.title }}
                    </span>
                    <div class="download-buttons">
                        {% if episode.status %}
                            {# Dodajemy atrybut data-status dla stylizacji CSS #}
                            <span class="episode-status" data-status="{{ episode.status }}">[{{ episode.status }}]</span>
                        {% endif %}
                        <button onclick="downloadEpisode('{{ series_info.series_id }}', '{{ season_num }}', '{{ episode.episode_id }}', '{{ episode.title | e }}', '{{ episode.ext }}')">Pobierz Odcinek</button>
                    </div>
                </li>
                {% endfor %}
            </ul>
            {% endfor %}
        </div>
        <p style="text-align: center; margin-top: 20px;"><a href="{{ url_for('seriale.seriale_list') }}">Powrót do listy seriali</a></p>
    </div>

    <div id="download-queue-widget" style="
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 300px;
        max-height: 400px;
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
        display: none;
        flex-direction: column;
        overflow: hidden;
    ">
        <div style="
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        " id="queue-header">
            <span>Kolejka pobierania</span>
            <button id="toggle-queue-widget" style="
                background: none;
                border: none;
                color: white;
                font-size: 1.2em;
                cursor: pointer;
                padding: 0 5px;
            ">✕</button>
        </div>
        <div id="queue-content" style="
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 0.9em;
            color: #343a40;
        ">
            <p style="text-align: center; margin: 10px 0;">Ładowanie kolejki...</p>
            <ul id="queue-list" style="list-style: none; padding: 0; margin: 0;">
                </ul>
        </div>
    </div>
    <button id="toggle-queue-btn">↓</button>

    <script>
        // Funkcja do pobierania pojedynczego odcinka
        async function downloadEpisode(seriesId, seasonNum, episodeId, episodeTitle, ext) {
            const seriesFolderName = encodeURIComponent(document.querySelector('h1').innerText.split('(')[0].trim());
            const episodeTitleSanitized = encodeURIComponent(episodeTitle);
            const url = `{{ url_for('seriale.download_episode') }}?series_id=${seriesId}&season=${seasonNum}&episode_id=${episodeId}&series_folder_name=${seriesFolderName}&episode_title=${episodeTitleSanitized}&ext=${ext}`;
            try {
                const response = await fetch(url, { method: 'POST' });
                const result = await response.text();
                alert(result);
                // Po dodaniu do kolejki, odśwież widok, aby pokazać status
                if (response.ok) {
                    // Możesz tu wywołać updateQueueWidget() jeśli chcesz natychmiast odświeżyć status
                    // lub po prostu odświeżyć całą stronę, aby pobrać nowy status
                    location.reload(); 
                }
            } catch (error) {
                console.error('Błąd:', error);
                alert('Wystąpił błąd podczas dodawania do kolejki: ' + error.message);
            }
        }

        // ... (Twój kod JavaScript dla pływającego widżetu kolejki - skopiuj z seriale_list.html) ...
        // Pamiętaj, aby opakować go w DOMContentLoaded jak poprzednio!

        window.addEventListener('DOMContentLoaded', function() {
            const queueWidget = document.getElementById('download-queue-widget');
            const queueHeader = document.getElementById('queue-header');
            const toggleQueueWidgetBtn = document.getElementById('toggle-queue-widget');
            const toggleQueueBtn = document.getElementById('toggle-queue-btn');
            const queueList = document.getElementById('queue-list');

            let isDragging = false;
            let offsetX, offsetY;

            async function updateQueueWidget() {
                try {
                    const statusResponse = await fetch('{{ url_for("seriale.queue_status") }}');
                    const statusData = await statusResponse.json();
                    
                    const fullQueueResponse = await fetch('{{ url_for("seriale.get_full_queue") }}');
                    const fullQueueData = await fullQueueResponse.json();

                    queueList.innerHTML = '';
                    if (fullQueueData.length === 0) {
                        queueList.innerHTML = '<p style="text-align: center; margin: 10px 0;">Kolejka jest pusta.</p>';
                    } else {
                        fullQueueData.forEach(job => {
                            const listItem = document.createElement('li');
                            const statusChar = statusData[job.episode_id] || '❓';
                            listItem.innerHTML = `
                                <span>${statusChar} ${job.file}</span>
                                <button data-episode-id="${job.episode_id}">Usuń</button>
                            `;
                            queueList.appendChild(listItem);
                        });
                    }
                } catch (error) {
                    console.error('Błąd podczas aktualizacji kolejki:', error);
                    queueList.innerHTML = '<p style="color: red; text-align: center;">Nie udało się załadować kolejki.</p>';
                }
            }

            async function removeFromQueue(episodeId) {
                try {
                    const response = await fetch('{{ url_for("seriale.queue_remove") }}', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({ id: episodeId })
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    await updateQueueWidget();
                    alert('Element usunięty z kolejki.');
                    location.reload(); // Odśwież stronę po usunięciu, aby zaktualizować status odcinka
                } catch (error) {
                    console.error('Błąd podczas usuwania z kolejki:', error);
                    alert('Wystąpił błąd podczas usuwania elementu z kolejki: ' + error.message);
                }
            }

            queueList.addEventListener('click', (event) => {
                if (event.target.tagName === 'BUTTON' && event.target.hasAttribute('data-episode-id')) {
                    const episodeId = event.target.getAttribute('data-episode-id');
                    removeFromQueue(episodeId);
                }
            });

            toggleQueueWidgetBtn.addEventListener('click', () => {
                queueWidget.style.display = 'none';
                toggleQueueBtn.style.display = 'flex';
            });

            toggleQueueBtn.addEventListener('click', () => {
                queueWidget.style.display = 'flex';
                toggleQueueBtn.style.display = 'none';
                updateQueueWidget();
            });

            queueHeader.addEventListener('mousedown', (e) => {
                isDragging = true;
                offsetX = e.clientX - queueWidget.getBoundingClientRect().left;
                offsetY = e.clientY - queueWidget.getBoundingClientRect().top;
                queueWidget.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                queueWidget.style.left = (e.clientX - offsetX) + 'px';
                queueWidget.style.top = (e.clientY - offsetY) + 'px';
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                queueWidget.style.cursor = 'grab';
            });

            setInterval(updateQueueWidget, 5000);
            
            queueWidget.style.display = 'none';
            toggleQueueBtn.style.display = 'flex';
        });
    </script>
</body>
</html>